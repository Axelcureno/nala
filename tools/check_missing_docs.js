// only checking named functions, class, and named class methods

const esprima = require('esprima');
const fs = require('fs');
const glob = require('glob');
const yargs = require('yargs');
const path = require('path');

const funcExpressionArr = [
  //   'ArrowFunctionExpression',
  //   'FunctionExpression',
  'FunctionDeclaration'
];

// const CHECKED_CNT = 'Total classes/functions checked';
// const MISSED_CNT = 'Classes/functions with missing documentation';
// const PERCENTAGE = 'Complete Percentage';
const CHECKED_CNT = 'totalChecked';
const MISSED_CNT = 'missingDoc';
const PERCENTAGE = 'completePercentage';

/**
 * Comment check result of a function
 * @typedef {file: string,  name: string, startLine: number, reason: string} commentCheckedResult
 */

// /**
//  * Check result of a file
//  * @typedef {file: string, missing: commentCheckedResult[]} fileCheckedResult
//  */

/**
 * Check for function comments in one file
 * @param {string} file Filename being checked
 * @returns {Object}- Information of check result of a file.
 * Contains checkedCnt in number, missedCnt in number, and missingFuncArr in commentCheckedResult[]
 */
function findMissingFuncInFile(file) {
  let lines = fs.readFileSync(file, 'utf-8');
  try {
    const tree = esprima.parse(lines, {
      sourceType: 'module',
      loc: true,
      attachComment: true
    });
    let checkedCnt = 0;
    let missedCnt = 0;
    // let summary = { file, missing: [] };
    let missingFuncsArr = [];
    for (let b of tree.body) {
      const parsed = handleParsing(b, file);
      if (!parsed) continue; // not a function
      const { missed, cnt } = parsed;

      checkedCnt += cnt;
      if (missed) {
        if (Array.isArray(missed)) {
          for (let oneMissed of missed) {
            // summary.missing.push(oneMissed);
            missingFuncsArr.push(oneMissed);
            missedCnt++;
          }
        } else {
          // summary.missing.push(missed);
          missingFuncsArr.push(missed);
          missedCnt++;
        }
      }
    }
    return { checkedCnt, missedCnt, missingFuncsArr };
  } catch (err) {
    // eat some exceptions

    // since esprima still does not support optional chaining in ES2020
    if (err.description === 'Unexpected token .') {
      console.log(`Eaten err in ${file} is:`);
      console.log(err);
      return { checkedCnt: 0, missedCnt: 0, missingFuncsArr: [] };
    }

    // since esprima still does not support optional catch argument in ES2019
    if (err.description === 'Unexpected token {') {
      console.log(`Eaten err in ${file} is:`);
      console.log(err);
      return { checkedCnt: 0, missedCnt: 0, missingFuncsArr: [] };
    }
    // rethrow for other exceptions
    throw err;
  }
}

/**
 * Parse one part of a parsed tree that's generated by parsing a file
 * @param {Object} b one parsed part of a parsed tree
 * @param {string} file name of the file
 * @returns {missed: commentCheckedResult | commentCheckedResult[], cnt: number} - check result and how many funcs checked
 */
function handleParsing(b, file) {
  if (b.type === 'FunctionDeclaration') {
    return { missed: checkComment(b, b.id.name, file), cnt: 1 };
  } else if (b.type === 'ClassDeclaration') {
    return handleClassDeclaration(b, file);
  } else if (b.type === 'ExportNamedDeclaration') {
    const decType = b.declaration.type;
    if (funcExpressionArr.includes(decType)) {
      return { missed: checkComment(b, b.declaration.id.name, file), cnt: 1 };
    } else if (decType === 'ClassDeclaration') {
      return handleClassDeclaration(b, file);
    }
  }
}

/**
 * Check comments for class declarations
 * Needed since the tree generated treats class declarations as special cases
 * @param {Object} b - one parsed part of a parsed tree
 * @param {string} file - name of the file
 * @returns {missed: commentCheckedResult[], cnt: number} - check result and how many methods checked
 */
function handleClassDeclaration(b, file) {
  let missedFuncs = [];
  let cnt = 0;
  let name =
    b.type === 'ExportNamedDeclaration' ? b.declaration.id.name : b.id.name;
  let checkClassComment = checkComment(b, 'class ' + name, file);
  cnt++;
  if (checkClassComment) missedFuncs.push(checkClassComment);
  let classBodyParts =
    b.type === 'ExportNamedDeclaration' ? b.declaration.body.body : b.body.body;
  for (let method of classBodyParts) {
    if (method.type === 'MethodDefinition') {
      cnt++;
      const checkMethodComment = checkComment(
        method,
        'method ' + method.key.name + ' in ' + 'class ' + name,
        file
      );
      if (checkMethodComment) missedFuncs.push(checkMethodComment);
    }
  }
  return { missed: missedFuncs, cnt };
}

/**
 * Check comments
 * @param {Object} b - one parsed part of a parsed tree
 * @param {string} name - name of the function
 * @param {string} file - name of the file
 * @returns {commentCheckedResult} - the check result
 */
function checkComment(b, name, file) {
  const missed = {
    file,
    name: name,
    startLine: b.loc.start.line
  };
  const comments = b.leadingComments;
  if (!comments) {
    missed.reason = 'not commented';
  } else {
    const comment = comments[comments.length - 1];
    if (comment.type != 'Block' || !comment.value.startsWith('*')) {
      missed.reason = "not jsDoc's /** */ format";
    } else if (!/\w/.test(comment.value)) {
      missed.reason = 'empty comment';
    } else if (
      (b.type === 'FunctionDeclaration' && !checkParams(comment, b.params)) ||
      (b.type === 'ExportNamedDeclaration' &&
        b.declaration.type === 'FunctionDeclaration' &&
        !checkParams(comment, b.declaration.params))
    ) {
      missed.reason = 'incomplete param descriptions';
    } else {
      // satisfied
      return null;
    }
  }
  // sth is missing
  return missed;
}

/**
 * Check comments
 * @param {string} comment - the comment content
 * @param {Object[]} params - array of param objects that contains name fields
 * @returns {boolean} - whether param descriptions are included
 */
function checkParams(comment, params) {
  let passed = true;
  for (let param of params) {
    var regex = new RegExp(`@param.*${param.name}.*\\w.*(\r|\n)`);
    if (!regex.test(comment.value)) {
      passed = false;
      break;
    }
  }
  return passed;
}

/**
 * Example: node .\tools\check_missing_docs.js -o ./tools/ -p '.\common\**\**.js' -f 'commonCheckedResult.json'
 *
 */
function main() {
  let argv = yargs
    .options('path', {
      alias: 'p',
      required: true,
      describe: 'glob pattern for files to be parsed'
    })
    .options('output', {
      alias: 'o',
      describe: 'output directory'
    })
    .options('filename', {
      alias: 'f',
      required: true,
      describe: 'filename'
    })
    .parserConfiguration({ 'strip-aliased': true }).argv;

  let files = glob.sync(argv.path);
  console.log('parsed files are:');
  console.log(files);

  let missingResults = { [CHECKED_CNT]: 0, [MISSED_CNT]: 0, funcs: [] };

  for (let f of files) {
    try {
      let { checkedCnt, missedCnt, missingFuncsArr } = findMissingFuncInFile(f);

      if (missingFuncsArr && missingFuncsArr.length > 0) {
        missingResults.funcs.push(...missingFuncsArr);
      }
      missingResults[CHECKED_CNT] += checkedCnt;
      missingResults[MISSED_CNT] += missedCnt;
    } catch (e) {
      console.log(`Error while processing "${f}"`);
      console.log(e);
      throw e;
    }
  }
  missingResults[PERCENTAGE] =
    (
      ((missingResults[CHECKED_CNT] - missingResults[MISSED_CNT]) /
        missingResults[CHECKED_CNT]) *
      100
    ).toFixed(2) + '%';

  if (argv.output) {
    fs.writeFileSync(
      path.join(argv.output, argv.filename),
      JSON.stringify(missingResults, null, 2)
    );
  } else {
    fs.writeFileSync(argv.filename, JSON.stringify(missingResults, null, 2));
  }
}
main();
